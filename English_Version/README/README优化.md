## 优化相关

> 新增基本块和流图两个类来辅助管理数据和优化。

### 基础数据结构

#### 基本块

##### 构建基本块

基本块维护块内的语句序列。

基本块通过序号进行标识。【-1表示出口】

##### 划分基本块

1. 确定入口序列：
   1. 整个序列的第一条语句【~~迷惑行为~~】
   2. 跳转语句的目的语句 【用label标识或者是函数名】
   3. 跳转语句的下一条语句【`j 或 jal`的下一条语句】

##### 产生use和def集合

> 注意：是针对变量的，不管寄存器、常量和字面量。

1. 产生use集合：只涉及赋值语句和表达式语句，把出现在右边的变量加入。
2. 产生def集合：【赋值语句和表达式语句】中左边的变量，且不在use集合中。

### 构建函数的流图

**每个函数维护自己的流图，通过<函数名，流图>建立映射关系**

**流图【有向图】需要知道**

流图通过基本块的序号对基本块进行索引

- 基本块的流动方向

  - 如果是被**branch**语句分开，那么基本块必须向后流动且向label流动
  - 如果是被**return**语句分开，那么基本块只能到函数出口
  - 如果是被**jump**语句分开，那么基本块只能向label流动

- 【紧随】 --- 通过跳转语句和顺序执行规律来构建流动方向。

  - 如果是被`jump`或者`return`隔开的两个基本块，基本块永远不可能见面

    ```
    return = jr ra
    ```

  - 如果是被分支语句隔开，则下一个基本块和当前基本块肯定还会见面。

  - 其他情况：直接顺序走下去。

##### 实现以下方法

- 产生到达定义方法

  输入：基本块的kill集合和gen集合

  输出：每个基本块入口和出口处的in，out集合

  算法改变的是in和out集合

- 活跃变量分析方法

  > 在流图中改变每个集合的in和out集合

  输入：基本块的use集合和def集合

  输出：每个基本块的入口和出口处的in集合和out集合
  
  算法流程：
  
  ```
  1. 将包括流图出口在内的基本块in集合初始化为空
  2. 重复
  		根据活跃变量分析方程，为每个基本块依次计算in[B]和out[B]；
  		【先计算out集合再计算in集合】
     直到所有基本块的in[B]集合不再变化为止
  ```

- 冲突-定义图

  变量的序号应该在活跃变量分析结束之后再产生，否则会带入一些没有使用的变量。

  ```
  1. 可以知道每个基本块入口处的活跃变量，以此构造冲突图
  	【遍历每一个冲突图，从中取出入口处的活跃变量集合，为这些活跃变量之间加上 边::冲突定义】
  2. 冲突图以数字作为索引，所以需要建立（数字 = 变量名）的双向映射关系。
  3. 根据冲突图可以按照算法分配全局寄存器
  ```

- 全局寄存器分配

  ```
  原则：有边相连的变量不能使用同一个寄存器，没有边相连的变量即使使用同一寄存器也没有关系。
  ```

  ```
  启发式算法：
  1. 从图中找到一个度<7的结点 // 因为我有一个寄存器被用来保存数组下标了。
  2. 重复步骤1 记录结点的移走次序，直到无法移走任何结点 // 移走需要删除该点和与相连的所有边
  3. 在图中选取一个适当的结点，将它标识为不分配全局寄存器，并从图中移走
  4. 重复1-3，直到图中剩余一个结点。
  5. 为这个剩余结点分配一个全局寄存器，按照结点被移走的顺序，逆序将结点和边添加进去，并依次给新加入的结点选取寄存器。只要保证有边相连的结点使用的寄存器不同即可。
  ```

  

#### 【疑惑】

- 到达定义好像没什么用。

### 基本块内的优化

- DAG图 --- 数据结构？？ 【有向无环图】

  涉及两个算法：中间代码生成DAG图、从DAG图导出中间代码

  注意: 函数调用和数组赋值有可能改变DAG图。

##### 窥孔优化

> 在一个较小的局部范围内，减少冗余指令。

- 来回赋值

  ```
  move $s1,$s2
  move $s2,$s1
  ```

- 无效跳转

  ```
  j Label1
  Label1: 
  // 标签紧接在跳转语句之后
  ```

- 无效运算

  ```
  add $s0 $s0 0
  mult $s0 1
  ```


#### 窥孔

```
$t2 = $s0  * $s1
$t3 = $s2  + $t2
$s1= $t3 // 没必要
$t4 = $s0  / $s1
$t5 = $s2  + $t4
$s0= $t5 // 没必要
特征：
上一句是表达式，下一句是赋值语句。那么
1. 将赋值语句的目标直接设置为表达式的目标
2. 将赋值语句去掉
在流图中做
```



### 寄存器分配

> 全局寄存器的分配对象是函数的局部变量，包括函数的入口参数。

- 引用计数

  统计变量的使用次数，根据被【引用的特点】（是否处于循环内部）赋予权值，然后排序，优先分配寄存器。

- 图着色

  为不相关的变量分配同一个全局寄存器。

#### 特殊寄存器分配

> 数组赋值处，利用`v1`保存数组下标。【实在找不到方法才出此下策】

### 数据流分析



### 内联自动化

> 如何判断一个函数是否可以内联？答曰：函数内部不在调用其他函数则可以内联
>
> 如何对一个【黑箱函数进行内联】？答曰：把函数内部的语句拷贝到调用处

函数调用的时候需要直到修改了哪些寄存器 :: 大致思路，具体实现细节还要待定

```
$a1 - $a3 || $t0 - $t7 || $ra::如果函数内部还有函数调用那就需要保存ra

目标函数中def的寄存器需要保存。
// 这里没办法泛化了，因为不同函数不同位置的调用得不到统一。
所以 :: 直接方法：函数里面def哪些寄存器就保存哪些寄存器。
如果函数内部还存在函数调用，有可能是递归函数，需要保存a0-a3

调用语句：
target::调用函数
left :: 返回到的寄存器
```


### 表达式优化

复习的时候得到的启发：

![1576027072335](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1576027072335.png)

表达式的计算可以简化很多：如果将常量在表达式计算的时候就计算出来，就不要中间寄存器来保存结果了。

### 测试代码结构

```
函数区
1. 返回参数加一个全局变量 --- 可以内联解决
2. 递归函数阶乘 --- 可以改成循环：因为递归需要保存现场
3. mod 函数 --- 内联解决
4. swap函数，可以内联处理，或者直接j过去，j回来
5. 水仙花数和拼接三位数 ： 内联
```





### 面向代码的优化

#### 阶乘函数

> 打表法：注意阶乘要保证在int范围内一定不会超过15。所以可以使用一个局部（或全局）数组来搞。

![1575458192866](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1575458192866.png)