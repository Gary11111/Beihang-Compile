# 编译课程设计最终总结文档

## 词法、语法分析部分

> 由于这部分比较简单，所以只进行简单的思路分析，抛砖引玉。

**设计思想**：尽可能的满足面向对象的五大设计原则。

- 开闭原则：软件实体应该对外扩展开放，对内修改关闭。

- 里氏替换原则：在所有引用基类的地方必须透明的使用其派生类的对象。

  > - **不应该在代码中出现if/else之类对派生类类型进行判断的条件。**
  > - **派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作**

  在编译器的设计中，最突出的地方在于【语句】的选择，比如，读入一个if, 一个`printf`，我们应该可以直接找到对应的`子语句解析器`(可能是继承自一个抽象的语句类)。然后由该子解析器完成语法分析。

- 最少知道原则：可以简单理解为：只与你直接的朋友们通信，不要跟“陌生人”说话。即：类之间的信息流动不能暴露给没有联系的其他类。

- 单一职责原则：不要让一个类存在多个改变的理由。

  > 换句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。

- 接口分隔原则

  > 不能强迫用户去依赖那些他们不使用的接口

~~最后两条原则好像与我的编译器无关，太菜了，不会用~~

## 错误处理部分

### 符号表相关

**参数名**：属于函数的下层，但在函数编译完成后，它与函数处于同一层，但是名字必须去掉。

**栈式符号表**：当前正在查表的元素一定位于栈顶。

push和drop时应同时对分程序索引表进行修改。

**删除**：有可能出现删除全局的情况：这时候程序已经结束，可以清空整个符号表。

**全局符号表**：使用map，用标识符的名称作为索引。

**无符号整数**：不能包含前导零。(未修改)

### 函数定义

> 在定义时将函数的参数个数保存在符号表中
>
> 函数定义结束后，需要将函数内的局部变量清除
>
> 为符号表新增一个“参数域”，用来保存函数的参数

### 错误处理相关

#### 重大修改：

输出流由词法分析器共享变为全局输出文件流。

#### 提前声明

- 凡是名字为tmp的变量都是用来占位置的，没有实际的用处。
- ``ownsRet`` : 是一个综合属性，用来判断函数是否拥有了正确的返回值。--- 这个设置十分危险，赶紧改掉。 --- 不知道怎么想出来的这个愚蠢设计。

#### 条件判断中出现不合法的类型

1. **整型表达式**之间才能进行运算

   可以通过对偶问题来解决

错误处理：预读（预判断处理）：如果非法，那么需要退回。

#### 词法分析错误处理

词法分析器中包含的错误类型不多，因此，将错误处理放到词法分析内部

#### 语法分析错误处理

##### 名字重定义：

在标识符定义处查符号表。

##### 未定义的名字：

- ​	放在符号表中的一个全局函数，每次使用标识符的地方都要检查
- ​	使用标识符的地方：因子、赋值语句、for、函数调用、读语句
- 函数调用中：如果函数名称未定义，不能跳过值参数表的解析，而应该跳过与原函数的比较。

##### 函数参数问题

- 函数参数个数不匹配：值参数表解析 + 查符号表
- 函数参数类型不匹配：值参数表解析 + 查符号表
- 在值参数表解析中，将右小括号吃掉。

##### **数组的参数只能是整型表达式**

变量定义（变量定义里有可能不符合语法）、因子、赋值语句

##### **改变常量的值**：

赋值语句: 常量出现在赋值语句右边. 如果右边是常量，则直接跳过赋值语句.

**常量定义中=后面只能是整型或字符型常量**

- int型常量
- char 型常量

##### **应为分号**

- 语句结束
- 常量定义
- 变量定义
- for语句中间

##### **应为右小括号**

- **函数值参数表**

  - 逗号：正常，继续循环
  - 小括号：正常，退出
  - 分号：缺少小括号，退出
  - 其他：缺少小括号，并且退出

- 表达式因子

- 函数参数表

- main函数的参数表

- 条件：条件语句和循环语句

- for语句

- return

- printf 

- scanf

- 关于空语句

  这种是否合法

  ```
  if(a>b){} // 需要有分号吗
  ```

  ![1572231669932](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1572231669932.png)

##### **应为右中括号]**

- 出现数组的地方
  - 变量定义处
  - 因子
  - 赋值语句

##### **return相关**

- 从return分析语句开始，构造继承属性，经过【语句，语句列，复合语句】才能到达【函数层】，试着发现一条捷径？？---可以，使用引用，通过改变引用避免改变函数的返回值
- 允许有多条return语句，只要有一个类型不符合，就会报错
- 有返回值函数定义中没有出现类型匹配的return

> 分割线 -------------------------------------------------------------- 以上为10月的设计初稿，以下为12月的改进

设置一个属性，用来标识函数是否存在返回值。~~~这样做虽然不太优雅，但是正确性得到保障~~

**条件判断**

要求表达式必须是整型

- 单表达式
- 双表达式

#### 符号表错误处理

名字重定义：放在查表中。



### 整型表达式--done

> 情况一：char型变量，常量，数组元素，函数调用
>
> 情况二：字符字面量

- 函数返回值return语句
- 数组元素下标
- 条件判断

> 注意在整型表达式分析的过程中，采用了如下结构，是为了保证一旦整型表达式被建立，不管其后加入char型与否，都不再改变其类型。

![1572518715460](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1572518715460.png)



### 编译遇到的错误

> 在词法分析头函数中定义了extern变量，但是在源文件中找不到。
>
> 这个问题很难搞，最后只能把输出改为追加式。（幸好没有多线程）



### 测试

### 单元测试

- b类问题：名字重定义
- c类问题：名字未定义
- d类问题：函数参数个数不对
- 

### 论坛

> 建议：看论坛要选择一个集中的时间汲取，一次性归纳出其中的精华，舍弃其糟粕内容。

- 大家的作业编译器中不需要判断每个路径是否有return语句，测试程序中每个分支都有return语句的。

- 不需要进行永假式/永真式检测。

- 不符合词法

  - 1. 出现词法规则里不允许出现的符号（在词法分析的过程中找出非法符号）
    2. 在定义字符的时候，同一行中没有找到配对的右单引号
    3. 在定义字符串的时候，同一行中没有找到配对的右双引号

  其他只要在词法分析中能正确识别的，都在语法分析中进行进一步判断是否符合相应的语法规则  

- 标识符重定义：按照第一次的标准来定义



### 难以处理

- ### 词法分析

  ```
  const int co#nst1 = 1, cons*t2 = -100;
  const char 0const13 = 'a';
  // 中间要是有非法字符怎么处理
  // 要是数字开头的标识符怎么识别
  ```

- ### 函数调用值参数表

  一旦参数表为空并且缺少右括号

- ### 函数调用因子：

  如果函数未定义那么因子的类型如何定义？

- 函数类型无法传入内部的语句列解析中，导致return语句在模块内部无法得到正确的结果。

- ~~不能有前导零这个问题始终没有考虑~~【最终还是苟过去了，现在感觉这并不是一个很大的问题，太细节的东西尽量往后放也是没错的。】

### 如果有一天

> 如果有一天需要尽可能多的输出错误：

- 函数值参数表的解析

  函数参数个数不匹配的时候直接跳过了类型检查

## 代码生成部分

## 思想 --- 栈式抽象机

> 即将使用的结果永远保存在抽象机的顶部

### 前期准备

> 一定不能贸然实现代码，一定要先架构好，至少先把大致方向确定了，再实现内部细节！

#### 大体构想

- 枚举四元式类型
- 设置四元式处理的类
- 将所有要输出的中间代码保存在动态数组中，统一输出 --- 为了能正确生成Label
- 栈式抽象机 --- 可以理解成需要计算的元素总在栈顶。

#### 枚举四元式类型

#### 设计四元式类

> JAVA中用类代替了结构体，所以使用类对于正确性肯定没有影响。

### 中间代码生成

##### 注意语句分析的完整性！！

> 按照中缀表达式表示

##### 函数声明 ✔

```
源码形如：
	int foo( int a, int b, int c, int d)
中间代码：
	int foo()
	para int a
	para int b
	para int c
	para int d
```

##### 函数调用 ✔

出现情况 :: 单独成为一条语句或成为因子。

```
源码形如：
	i = tar(x,y)
中间代码：
	push x
	push y
	call tar
	i = RET
```

``funcRefParse()`` :: 返回一个表达式的临时变量标识。



##### 函数返回 ✔

```
源码形如：
	return (x)
中间代码：
	ret x
```

先保存表达式的值，然后再返回记录表达式值的临时变量。

##### 变量声明 ✔

数组定义也可以处理了。

##### 常数声明 ✔

第二个运算符为空，只有第一个运算符。

##### 表达式【可优化】  ✔

> --- 第一阶段的难点在于如何解析表达式 --- 递归下降法

**注：现在不用错误处理了，因此项和因子的返回值类型都可以重新定义。**

【超难点】

- 表达式一定要有返回值 --- 返回储存表达式最终结果的变量

  > 因为表达式不可能单独出现

- 在表达式分析的过程结束的时候就应该将内容（经过逆波兰转换的表达式）保存到全局的中间代码中 【不然没法处理啊…】

- 表达式的返回值 --- 应该通过genVar()来产生一个名称。

- ###### 适应变化

  - 表达式的返回值
  - 项的返回值
  - 因子的返回值
  - 函数调用的返回值

- ###### 表达式的计算

  - 生成逆波兰表达式

    中缀表达式转后缀表达式，假设没有括号

    从左往右扫描表达式串，对于表达式串的每一个元素

    - 如果是标识符，直接输出。
    - 如果是加法运算符：将之前的加法运算符输出，并且入栈。
    - 如果是乘法运算符：直接输出。

    如果栈不为空，输出栈中所有元素。

  - 由逆波兰表达式生成中间代码

    逆波兰表达式的计算

    > 在表达式计算中可以产生四元式。
    >
    > 一个运算符对应一个输出，对应一个临时变量。

    - 建立一个数据结构 --- 栈 --- 存储运算结果。
    - 每次遇到一个标识符将其压入栈中
    - 每次遇到一个运算符，从栈中弹出两个元素进行运算，并且将结果加入栈中。
    - 最后栈顶的元素就是表达式的结果。

##### 条件判断 --- 照原样生成即可 ✔

```
源码形如：
	x == y
中间代码：
	x == y
```

> 【疑问】如果条件判断只有一个表达式？？

##### 条件或无条件跳转 ✔

> 条件还有另一个名字，曰：cmp（比较）

**注意**

- ``mips``中处理比较的方式。
- 是先产生跳转指令，然后再设置label。用target保存label的名称。

跳转这里有点绕 --- mips的比较方式是将两个表达式的值相减然后与0进行比较。【需要在条件分析中完成这一步】

```
1. 目标条件取反
2. 左边为条件解析出的结果，右边为0 
3. 跳转
```

- if -- 控制语句将产生跳转
- 循环语句产生跳转

##### 带标号的语句 ✔

在语法分析的过程中产生

##### 数组赋值或取值 ✔

```
源码形如：
	a[i] = b * c[j]
中间代码：
	t1 = c[j] // 这个地方需要注意一下
	t2 = b * t1
	a[i] = t2 
```

##### 循环语句的处理

- 循环变量会不断变化 --- 但是好像没有影响
- 每次循环体运行结束需要跳到循环体开头

##### 读语句 ✔

> 区分int和char

##### 写语句

【疑问】

​	char型变量赋值给string不会出问题吧。

- 字符串按照原样输出，不存在转义的问题
- 字符串和表达式之间无空格
- 表达式为整型，直接输出整数
- 表达式为字符型，输出字符
- 每个printf结束都要输出换行符

#### 难点

表达式的解析，这是一个模块嵌套的问题。

- 判断是否为标识符 --- 这个在逆波兰表达式的转换中十分重要.

#### 中间代码的输出

- 先全部保存到vector中，然后遍历vector进行输出。
- 函数定义时参数有两种方法：1. 每出现一个参数就生成一条中间语句。2. 将所有参数统一保存，统一生成。【我选择了后者】
- 函数调用时,形参的传递也有两种方式。（类似上面）

##### 不同类型的四元式输出

- 条件 --- 添加标志``CMP``

  1. 只有一个表达式
  2. 两个**整型**表达式做比较

- 条件或无条件跳转

  无条件跳转 --- GOTO

  条件跳转：$$<满足的跳转条件> Label$$

- 读语句

  1. 读入一个字符
  2. 读入一个整数

#### 待处理

- 临时变量编号的清零
- 如何减少寄存器的使用  --- 进入前保存varCount，出来前恢复varCount。
  - 将tmpVar设置为0
    - 复合语句
    - if语句的statement之前；else 语句分析之后
    - 表达式分析结束
    - 条件分析结束

#### 测试过程

> 不要抵触读代码

- 先把样例过了
- 拿**正确的测试程序(之前收集的)**进行覆盖性测试

### 中间代码生成mips汇编

> #### 优化方法

- 基本块内的优化
  - DAG图 --- 防止基本块内的表达式重复计算，但是要注意数组和函数引用的情况。
  - 窥孔优化
  - 常量合并和传播
- 全局优化
  - 到达定义分析
  - 活跃变量分析
  - 消除**全局**公共子表达式
  - 复制传播
  - 死代码删除

> #### 针对每一种中间代码生成汇编语句

##### 函数调用语句

> 统一规定（默认的）
>
> 函数参数保存在``$a0~$a3``中，如果多于4个参数，就保存在栈中。

jal 直接跳到函数名名称

函数结束时，记得加上jr ra。

##### 赋值语句

- 赋值语句的**左边**是取地址赋值，即包含两个步骤

  1. 获取变量所在的地址。
  2. 通过``sw``对变量所在的地址进行赋值。

  注意 ：数组元素的下标是取值。

- 赋值语句的右边是取值操作 -- 使用 ``lw``

```
中间代码
target :: 保存了赋值语句的目标
left :: 保存了赋值语句的右边

mips:
$t2 :: 保存赋值的目标地址
$k0 :: 保存局部变量的基地址
$k1 :: 保存局部变量的偏移
```

##### 标签

##### 数组定义

数组全部定义成全局变量，放在data段。

> 注意：data段是从0x00000000开始分配内存的。

```
.data
symbol:.space 28
array:.space 28 // 为数组分配空间，一个int类型占4字节
```

##### 变量定义

【变量定义到底放在哪比较合适：data区】

要区分全局变量和局部变量。

##### 常量定义

不在mips中定义，使用的时候直接赋值。

##### 函数定义

进入函数时，要保存ra寄存器的返回地址；

函数跳出之前，要恢复函数的运行栈。

- 参数相关

  > 假设参数小于四个: and :都不会被def，只会被use。

  为了区别参数和局部变量，参数的value值设置为``19981111``

- 返回值相关

  如果void类型的函数没有返回值，需要在最末尾添加一条返回值语句。

##### 表达式

**注意**：在genTempAddr()函数中，做出了如下归一化处理：

```
string Optimizer::getTempReg(const string &tempReg, const string &dstReg) {
    string localOffset = tempReg.substr(1, tempReg.length() - 1);
    mipsFile << "move " << dstReg << ", $t" + to_string(stoi(localOffset) % 8) << endl;
    return dstReg; // 这里返回什么还没想好
}
// 可以保证表达式所用的寄存器编号不超过 8

```

注意一下表达式赋值的计算顺序：

先计算表达式右边的运算，然后赋值给左边。

```
表达式左边肯定是一个临时寄存器
表达式右边是两个因子
target :: 赋值目标
left :: 第一个操作数 用寄存器t8保存
right :: 第二个操作数 用寄存器t9保存

```



##### 条件

##### 无条件跳转语句

##### 读语句

- 整数
- 字符

##### 写语句

- 字符串 :: 最终要打印的字符串统一放在data段进行输出，包括换行符和空格。

  **注意这个地方必须要像4字节对齐**。

  ```
  需要定义时
  string1 :.asciiz "abcdefg!@$!$#%!#$^"
  
  需要打印时：
  la $a0, space
  li $v0, 4
  syscall // 就可以打印空格
  
  ```

- 整数

  ```
  syscall 11 // 输出整数
  
  ```

- 字符

  ```
  out << "li $a0 " << (int)item.target.at(0) << endl;
  out << "li $v0 11" << endl;
  out << "syscall" << endl;
  // 先一个强转，得到ascii值，然后直接用syscall 11来输出字符
  
  ```

##### 返回语句

1. 恢复寄存器 -- 根据函数定义时保存的寄存器来恢复
2. ``jr ra``

### 第三步 --- 优化方案

- 基本块内的优化

  建立DAG图,消除公共子表达式(针对每一个```基本块```)

- 删除冗余代码

  恒等式的删除：比如 x = x + 0; x = x - 0; a[3] = a[3] + 0;

  常数值传播 --- 临时变量的重复利用(一个函数内存在大量的临时变量只使用过一次就再也没有用的情况)--->针对```基本块```的重新规划

- 使用全局寄存器 ``s0~s7``来保存**高频使用的全局变量**的值。

### 寄存器分配

```
sp -> 整个程序的运行栈空间
fp -> 函数的起始地址
k0, k1 -> 用来计算数组、局部变量的地址（tmp）
/* 函数定义中需要保存的寄存器：
s0~s7 :: 全局寄存器
$a0 ~ $a3 :: 函数的参数
fp :: 函数运行栈的开始地址 --- 便于恢复栈指针
函数返回需要恢复的寄存器*/

```

### 调试

```
【棘手】 函数中的定义的局部常量和变量有可能与全局的变量和常量名冲突
      :: 这在语法分析的时候对分析类型会造成麻烦 
      测试程序没有
【棘手】 归并排序中 inner_merge_sort结尾没有return的情况
【坑点】 "\n"只占用一个字符
【测试】 归并排序
【不明修改】 变量定义处删除了一条中间代码
【修改】 函数的栈空间 --- 增加多余参数的存储空间
【有可能对参数赋值】
【参数必将小于4】
【全局寄存器分配】
 $s1 : 循环变量自增保护
 $s0 : 数组下标保护

```

## 代码结构

#### 函数引用

- 保存现场
- 产生函数调用的参数 :: 通过getEleValue把值装载到$a0寄存器中
- jal 直接跳到函数
- 从$v0中获取函数的返回值

#### 赋值语句

- 确定赋值语句的右边 -> 放在$k1中
- 数组元素的左边有可能是：全局变量/局部变量/(全局数组/局部数组)

#### 表达式语句

右边的元素可能是：

- 变量
  - 局部变量
  - 全局变量
- 常量 --- 都定义成Global就好
  - 局部常量
  - 全局常量
- 数组
  - 局部数组
  - 全局数组
- 寄存器
- 函数参数

#### 函数定义

- localOffset 和 nameToLocalVar 清空 == 局部变量的计数器和局部变量索引清空
- 设置codeScope表示当前正在分析的区域
- 产生函数名称的target
- **初始化函数的运行栈** :: 这一步特别重要

#### 跳转语句

- 跳转语句类别::保存在four.right中

- 跳转语句的判断条件是four.left与0之间的比较（**这个地方要确保比较的对象是一个寄存器**）

  如果比较对象是一个寄存器的话，那就可以直接添加。

- 跳转的目的地保存在four.target中

#### 读语句

- 读到$v0中
- 目标：局部变量/全局变量

#### 写语句

- 保护$a0
- 改变$a0
- 输出
- 恢复$a0

#### 返回语句

- 判断函数类型

  void 类型：跳过$v0的产生

  main类型: 直接退出

  int/char 类型：先产生返回值

- 恢复寄存器

- ``jr $ra``

## 代码优化部分

### 针对特定代码的优化 

最重要的一点：优化是建立在【正确性】的基础之上的。

> 逐层优化 :: 可以想象成粒子加速器的模式，一级一级的优化

```
    optFactorial(); // 优化阶乘函数
    optSwap(); // 优化交换部分
    optMod(); // 优化取余部分
    optFull_Num(); // 优化full_num函数
    optFlowerArea(); // 优化水仙花数那块区域
    optRidDeadCode(); // 删除死代码
    genTmpCode(); // 产生中间代码
```

